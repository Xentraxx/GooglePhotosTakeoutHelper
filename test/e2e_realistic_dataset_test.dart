/// # Comprehensive End-to-End Tests for Google Photos Takeout Helper
///
/// This test suite validates the complete behavior of GPTH using realistic
/// datasets generated by the generateRealisticTakeoutDataset() function.
/// It tests all possible flag combinations and validates the expected number
/// of output files and folders.
///
/// ## Test Coverage
///
/// ### Album Behaviors Tested
/// - shortcut: Creates shortcuts/symlinks to files in ALL_PHOTOS
/// - duplicate-copy: Creates actual file copies in both locations
/// - reverse-shortcut: Files stay in albums, shortcuts in ALL_PHOTOS
/// - json: Single folder with albums-info.json metadata
/// - nothing: Ignores albums entirely
///
/// ### Date Division Options Tested
/// - 0: Single ALL_PHOTOS folder
/// - 1: Year folders (2023/, 2024/, etc.)
/// - 2: Year/Month folders (2023/01/, 2023/02/, etc.)
/// - 3: Year/Month/Day folders (2023/01/15/, 2023/01/16/, etc.)
///
/// ### Additional Flags Tested
/// - --copy vs move mode
/// - --skip-extras
/// - --write-exif
/// - --transform-pixel-mp
/// - Cross-platform compatibility (Windows shortcuts vs Unix symlinks)
///
/// ## Performance and Data Integrity
///
/// Each test validates:
/// - Correct file counts and folder structure
/// - Data integrity (file hashes match)
/// - Processing performance metrics
/// - Memory usage with large datasets
/// - Cross-platform shortcut/symlink behavior
// ignore_for_file: avoid_redundant_argument_values

library;

import 'dart:convert';
import 'dart:io';
import 'package:collection/collection.dart';
import 'package:crypto/crypto.dart';
import 'package:gpth/folder_classify.dart';
import 'package:path/path.dart' as p;
import 'package:test/test.dart';

import 'test_setup.dart';

void main() {
  group('E2E Realistic Dataset Tests', () {
    late TestFixture fixture;
    late String takeoutPath;
    late String outputPath;

    setUp(() async {
      fixture = TestFixture();
      await fixture.setUp();
      takeoutPath = await fixture.generateRealisticTakeoutDataset(
        yearSpan: 3,
        albumCount: 5,
        photosPerYear: 10,
        albumOnlyPhotos: 3,
        exifRatio: 0.7,
      );
      outputPath = p.join(fixture.basePath, 'output');
      await Directory(outputPath).create(recursive: true);
    });

    tearDown(() async {
      await fixture.tearDown();
    });

    group('Album Behavior Tests', () {
      /// Tests the `--albums shortcut` mode behavior
      ///
      /// **Purpose**: Validates that GPTH creates proper symlinks/shortcuts
      /// from album folders to files in ALL_PHOTOS, ensuring space efficiency.
      ///
      /// **Expected Behavior**:
      /// - Original files are placed in ALL_PHOTOS
      /// - Album folders contain platform-specific shortcuts (.lnk on Windows, symlinks on Unix)
      /// - No file content duplication occurs
      /// - All shortcuts/symlinks point to valid targets
      ///
      /// **Validations**:
      /// - File count in ALL_PHOTOS matches expected range
      /// - Correct number of album folders created
      /// - Platform-specific shortcut/symlink validation
      /// - Unique file hashes confirm no duplication
      test('Shortcut mode creates proper symlinks/shortcuts', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'shortcut',
          divideToDates: 0,
        );

        final results = await _analyzeOutput(outputPath);

        // Validate ALL_PHOTOS contains original files
        expect(results.allPhotosFiles.length, greaterThan(25));

        // Validate album folders contain shortcuts/symlinks
        expect(results.albumFolders.length, equals(5));

        for (final albumFolder in results.albumFolders) {
          final albumFiles = await _getFilesInDirectory(albumFolder);
          for (final file in albumFiles.where(
            (final f) => !f.path.endsWith('.json'),
          )) {
            if (Platform.isWindows) {
              // Windows shortcuts
              expect(file.path.endsWith('.lnk'), isTrue);
            } else {
              // Unix symlinks
              final link = Link(file.path);
              expect(await link.exists(), isTrue);
            }
          }
        }

        // Validate no duplicate file content (space efficiency)
        final uniqueHashes = await _getUniqueFileHashes(results.allPhotosFiles);
        expect(uniqueHashes.length, equals(results.allPhotosFiles.length));
      });

      /// Tests the `--albums duplicate-copy` mode behavior
      ///
      /// **Purpose**: Validates that GPTH creates actual file copies in both
      /// ALL_PHOTOS and album folders when duplicate-copy mode is used.
      ///
      /// **Expected Behavior**:
      /// - Files exist in both ALL_PHOTOS and album folders
      /// - Album folders contain actual file copies, not symlinks
      /// - File duplication increases total file count
      /// - All copied files have actual content and valid file sizes
      ///
      /// **Validations**:
      /// - ALL_PHOTOS contains expected number of files
      /// - Album folders contain actual files (not symlinks)
      /// - Total album files exceed ALL_PHOTOS files (indicating duplication)
      /// - All files have valid content and size > 0
      test('Duplicate-copy mode creates actual file copies', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'duplicate-copy',
          divideToDates: 0,
        );

        final results = await _analyzeOutput(outputPath);

        // Validate ALL_PHOTOS contains files
        expect(results.allPhotosFiles.length, greaterThan(25));

        // Validate album folders contain actual files
        expect(results.albumFolders.length, equals(5));

        int totalAlbumFiles = 0;
        for (final albumFolder in results.albumFolders) {
          final albumFiles = await _getFilesInDirectory(albumFolder);
          final imageFiles = albumFiles
              .where((final f) => !f.path.endsWith('.json'))
              .toList();
          totalAlbumFiles += imageFiles.length;

          for (final file in imageFiles) {
            // Verify these are actual files, not symlinks
            expect(await File(file.path).exists(), isTrue);
            expect(await Link(file.path).exists(), isFalse);

            // Verify file has actual content
            final fileSize = await file.length();
            expect(fileSize, greaterThan(0));
          }
        }

        // Validate file duplication (more files than unique content)
        expect(totalAlbumFiles, greaterThan(results.allPhotosFiles.length));
      });

      /// Tests the `--albums reverse-shortcut` mode behavior
      ///
      /// **Purpose**: Validates the reverse shortcut mode where original files
      /// remain in album folders and shortcuts are placed in ALL_PHOTOS.
      ///
      /// **Expected Behavior**:
      /// - Original files stay in their respective album folders
      /// - ALL_PHOTOS contains shortcuts/symlinks pointing to album files
      /// - Album folders contain actual files with content
      /// - Platform-specific shortcut/symlink behavior
      ///
      /// **Validations**:
      /// - Album folders contain original files (not symlinks)
      /// - ALL_PHOTOS contains platform-specific shortcuts/symlinks
      /// - All shortcuts/symlinks point to valid targets in album folders
      /// - File integrity maintained in album locations
      test('Reverse-shortcut mode keeps files in albums', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'reverse-shortcut',
          divideToDates: 0,
        );

        final results = await _analyzeOutput(outputPath);

        // Validate album folders contain original files
        expect(results.albumFolders.length, equals(5));

        // Validate ALL_PHOTOS contains shortcuts/symlinks
        for (final file in results.allPhotosFiles) {
          if (Platform.isWindows) {
            expect(file.path.endsWith('.lnk'), isTrue);
          } else {
            final link = Link(file.path);
            expect(await link.exists(), isTrue);
          }
        }

        // Validate album files are originals
        for (final albumFolder in results.albumFolders) {
          final albumFiles = await _getFilesInDirectory(albumFolder);
          final imageFiles = albumFiles
              .where((final f) => !f.path.endsWith('.json'))
              .toList();

          for (final file in imageFiles) {
            expect(await File(file.path).exists(), isTrue);
            expect(await Link(file.path).exists(), isFalse);
          }
        }
      });

      /// Tests the `--albums json` mode behavior
      ///
      /// **Purpose**: Validates that GPTH creates a single albums-info.json
      /// file containing album metadata instead of creating separate album folders.
      ///
      /// **Expected Behavior**:
      /// - All files are placed in ALL_PHOTOS
      /// - albums-info.json file is created in the output root
      /// - JSON structure maps filenames to their album memberships
      /// - No separate album folders are created
      ///
      /// **Validations**:
      /// - ALL_PHOTOS contains all processed files
      /// - albums-info.json exists and has valid JSON structure
      /// - JSON maps filenames (strings) to album lists (arrays)
      /// - No album folders exist in output directory
      test('JSON mode creates albums-info.json metadata', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'json',
          divideToDates: 0,
        );

        final results = await _analyzeOutput(outputPath);

        // Validate ALL_PHOTOS contains all files
        expect(results.allPhotosFiles.length, greaterThan(25));

        // Validate albums-info.json exists and has correct structure
        final albumsInfoFile = File(p.join(outputPath, 'albums-info.json'));
        expect(await albumsInfoFile.exists(), isTrue);

        final albumsInfo = jsonDecode(await albumsInfoFile.readAsString());
        expect(albumsInfo, isA<Map>());

        // Validate album information is properly structured
        for (final entry in albumsInfo.entries) {
          expect(entry.key, isA<String>()); // filename
          expect(entry.value, isA<List>()); // list of albums
        }

        // Validate no separate album folders exist
        expect(results.albumFolders.length, equals(0));
      });

      /// Tests the `--albums nothing` mode behavior
      ///
      /// **Purpose**: Validates that GPTH completely ignores album information
      /// and processes only the main photo files when nothing mode is used.
      ///
      /// **Expected Behavior**:
      /// - All files are placed in ALL_PHOTOS only
      /// - No album folders are created
      /// - No albums-info.json file is created
      /// - Album metadata is completely ignored
      ///
      /// **Validations**:
      /// - ALL_PHOTOS contains processed files
      /// - No album folders exist in output
      /// - No albums-info.json file exists
      /// - Clean output structure with only ALL_PHOTOS
      test('Nothing mode ignores albums completely', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'nothing',
          divideToDates: 0,
        );

        final results = await _analyzeOutput(outputPath);

        // Validate ALL_PHOTOS contains files
        expect(results.allPhotosFiles.length, greaterThan(20));

        // Validate no album folders exist
        expect(results.albumFolders.length, equals(0));

        // Validate no albums-info.json exists
        final albumsInfoFile = File(p.join(outputPath, 'albums-info.json'));
        expect(await albumsInfoFile.exists(), isFalse);
      });
    });

    group('Date Division Tests', () {
      /// Tests `--divide-to-dates 0` behavior (single folder organization)
      ///
      /// **Purpose**: Validates that all files are placed in a single ALL_PHOTOS
      /// folder without any date-based subdirectory organization.
      ///
      /// **Expected Behavior**:
      /// - ALL_PHOTOS directory exists and contains all files
      /// - No year, month, or day subdirectories are created
      /// - Flat file structure within ALL_PHOTOS
      ///
      /// **Validations**:
      /// - ALL_PHOTOS directory exists
      /// - No subdirectories exist within ALL_PHOTOS
      /// - All files are directly in ALL_PHOTOS root
      test('Date division 0: Single folder', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'shortcut',
          divideToDates: 0,
        );

        // All files should be in single ALL_PHOTOS folder
        final allPhotosDir = Directory(p.join(outputPath, 'ALL_PHOTOS'));
        expect(await allPhotosDir.exists(), isTrue);

        // No year subdirectories should exist in ALL_PHOTOS
        final subdirs = await allPhotosDir
            .list()
            .where((final e) => e is Directory)
            .toList();
        expect(subdirs.length, equals(0));
      });

      /// Tests `--divide-to-dates 1` behavior (year-based organization)
      ///
      /// **Purpose**: Validates that files are organized into year-based
      /// subdirectories within ALL_PHOTOS (e.g., 2023/, 2024/, etc.).
      ///
      /// **Expected Behavior**:
      /// - ALL_PHOTOS contains year subdirectories
      /// - Year directories follow YYYY format
      /// - Files are distributed into appropriate year folders
      /// - Year folders are properly recognized by isYearFolder()
      ///
      /// **Validations**:
      /// - ALL_PHOTOS directory exists
      /// - Year subdirectories are created and validated
      /// - Year directories contain files from appropriate time periods
      test('Date division 1: Year folders', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'shortcut',
          divideToDates: 1,
        );

        final allPhotosDir = Directory(p.join(outputPath, 'ALL_PHOTOS'));
        expect(await allPhotosDir.exists(), isTrue);

        // Should have year subdirectories using isYearFolder() for validation
        final yearDirs = <Directory>[];
        await for (final entity in allPhotosDir.list()) {
          if (entity is Directory && isYearFolder(entity)) {
            yearDirs.add(entity);
          }
        }

        expect(yearDirs.length, greaterThan(0));
      });

      /// Tests `--divide-to-dates 2` behavior (year/month organization)
      ///
      /// **Purpose**: Validates that files are organized into a two-level
      /// hierarchy: year folders containing month subdirectories.
      ///
      /// **Expected Behavior**:
      /// - ALL_PHOTOS contains year directories (YYYY format)
      /// - Year directories contain month subdirectories (01-12 format)
      /// - Files are distributed into appropriate year/month folders
      /// - Month directories use zero-padded numeric format
      ///
      /// **Validations**:
      /// - Year directories exist and are validated by isYearFolder()
      /// - Month directories exist within year folders
      /// - Month directory names are valid (01-12)
      /// - Proper hierarchical structure is maintained
      test('Date division 2: Year/Month folders', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'shortcut',
          divideToDates: 2,
        );

        final allPhotosDir = Directory(p.join(outputPath, 'ALL_PHOTOS'));
        expect(await allPhotosDir.exists(), isTrue);

        // Should have year/month subdirectories - validate year folders using isYearFolder()
        final yearDirs = <Directory>[];
        await for (final entity in allPhotosDir.list()) {
          if (entity is Directory && isYearFolder(entity)) {
            yearDirs.add(entity);
          }
        }
        expect(yearDirs.length, greaterThan(0));

        for (final yearDir in yearDirs) {
          final monthDirs = await Directory(yearDir.path)
              .list()
              .where((final e) => e is Directory)
              .map((final e) => p.basename(e.path))
              .toList();

          for (final monthDir in monthDirs) {
            final month = int.tryParse(monthDir);
            expect(month, isNotNull);
            expect(month!, greaterThanOrEqualTo(1));
            expect(month, lessThanOrEqualTo(12));
          }
        }
      });

      /// Tests `--divide-to-dates 3` behavior (year/month/day organization)
      ///
      /// **Purpose**: Validates that files are organized into a three-level
      /// hierarchy: year/month/day folders for maximum granularity.
      ///
      /// **Expected Behavior**:
      /// - ALL_PHOTOS contains year directories (YYYY format)
      /// - Year directories contain month subdirectories (01-12 format)
      /// - Month directories contain day subdirectories (01-31 format)
      /// - Files are distributed into appropriate year/month/day folders
      ///
      /// **Validations**:
      /// - Year directories exist and are validated by isYearFolder()
      /// - Month directories exist within year folders
      /// - Day directories exist within month folders
      /// - Day directory names are valid (01-31)
      /// - Complete three-level hierarchical structure
      test('Date division 3: Year/Month/Day folders', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'shortcut',
          divideToDates: 3,
        );

        final allPhotosDir = Directory(p.join(outputPath, 'ALL_PHOTOS'));
        expect(await allPhotosDir.exists(), isTrue);

        // Recursively check year/month/day structure - validate year folders using isYearFolder()
        final yearDirs = <Directory>[];
        await for (final entity in allPhotosDir.list()) {
          if (entity is Directory && isYearFolder(entity)) {
            yearDirs.add(entity);
          }
        }
        expect(yearDirs.length, greaterThan(0));

        for (final yearDir in yearDirs) {
          final monthDirs = await Directory(
            yearDir.path,
          ).list().where((final e) => e is Directory).toList();

          for (final monthDir in monthDirs) {
            final dayDirs = await Directory(monthDir.path)
                .list()
                .where((final e) => e is Directory)
                .map((final e) => p.basename(e.path))
                .toList();

            for (final dayDir in dayDirs) {
              final day = int.tryParse(dayDir);
              expect(day, isNotNull);
              expect(day!, greaterThanOrEqualTo(1));
              expect(day, lessThanOrEqualTo(31));
            }
          }
        }
      });
    });

    group('Additional Flag Tests', () {
      /// Tests `--copy` flag behavior (copy mode vs default move mode)
      ///
      /// **Purpose**: Validates that copy mode preserves original files in the
      /// takeout directory while creating organized output, unlike move mode.
      ///
      /// **Expected Behavior**:
      /// - Original files remain in takeout directory unchanged
      /// - Output directory is created with organized structure
      /// - File content integrity is maintained (hashes match)
      /// - No files are removed from original location
      ///
      /// **Validations**:
      /// - Original file count and hashes remain unchanged
      /// - Output contains expected number of processed files
      /// - Content verification through hash comparison
      /// - Source directory remains intact
      test('Copy mode preserves original files', () async {
        // Get original file count and hashes
        final originalFiles = await _getAllFiles(takeoutPath);
        final originalHashes = await _getFileHashes(originalFiles);

        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'shortcut',
          copy: true,
        );

        // Verify original files still exist with same content
        final stillExistingFiles = await _getAllFiles(takeoutPath);
        final currentHashes = await _getFileHashes(stillExistingFiles);

        expect(stillExistingFiles.length, equals(originalFiles.length));
        expect(currentHashes, equals(originalHashes));

        // Verify output was created
        final results = await _analyzeOutput(outputPath);
        expect(results.allPhotosFiles.length, greaterThan(20));
      });

      /// Tests default move mode behavior (files are moved, not copied)
      ///
      /// **Purpose**: Validates that the default move mode removes files from
      /// the original takeout directory while organizing them in the output.
      ///
      /// **Expected Behavior**:
      /// - Media files are moved from takeout to output directory
      /// - Fewer files remain in original location (only JSON/metadata)
      /// - Output directory contains the organized media files
      /// - Original directory is cleaned of processed media
      ///
      /// **Validations**:
      /// - Fewer files remain in original takeout directory
      /// - Output contains expected number of processed files
      /// - Only metadata/JSON files typically remain in source
      /// - Successful file transfer to organized output
      test('Move mode removes original files', () async {
        // Get original file count
        final originalFiles = await _getAllFiles(takeoutPath);

        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'shortcut',
          copy: false,
        );

        // Verify fewer original files remain (JSON and structure files)
        final remainingFiles = await _getAllFiles(takeoutPath);
        expect(remainingFiles.length, lessThan(originalFiles.length));

        // Verify output was created
        final results = await _analyzeOutput(outputPath);
        expect(results.allPhotosFiles.length, greaterThan(20));
      });

      /// Tests `--skip-extras` flag behavior (excludes extra files)
      ///
      /// **Purpose**: Validates that the skip-extras flag properly excludes
      /// extra files (like JSON metadata, edited versions) from processing.
      ///
      /// **Expected Behavior**:
      /// - Fewer files are processed when skip-extras is enabled
      /// - Only primary media files are included in output
      /// - Extra files (JSON, edited versions, etc.) are excluded
      /// - File count comparison shows reduction with skip-extras
      ///
      /// **Validations**:
      /// - Baseline run without skip-extras establishes file count
      /// - Run with skip-extras produces same or fewer files
      /// - Proper filtering of extra/metadata files
      /// - Core media files are still processed correctly
      test('Skip extras flag works correctly', () async {
        // First run without skip-extras to get baseline
        final outputWithExtras = p.join(fixture.basePath, 'output_with_extras');
        await Directory(outputWithExtras).create(recursive: true);

        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputWithExtras,
          albums: 'nothing',
          skipExtras: false,
        );

        final resultsWithExtras = await _analyzeOutput(outputWithExtras);

        // Run with skip-extras
        final outputWithoutExtras = p.join(
          fixture.basePath,
          'output_without_extras',
        );
        await Directory(outputWithoutExtras).create(recursive: true);

        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputWithoutExtras,
          albums: 'nothing',
          skipExtras: true,
        );

        final resultsWithoutExtras = await _analyzeOutput(outputWithoutExtras);

        // Should have same or fewer files when skipping extras
        expect(
          resultsWithoutExtras.allPhotosFiles.length,
          lessThanOrEqualTo(resultsWithExtras.allPhotosFiles.length),
        );
      });
    });

    group('Cross-Platform Compatibility Tests', () {
      /// Tests Windows-specific shortcut handling (.lnk files)
      ///
      /// **Purpose**: Validates that GPTH correctly creates Windows shortcuts
      /// (.lnk files) when running on Windows platform in shortcut mode.
      ///
      /// **Expected Behavior**:
      /// - .lnk files are created in album folders on Windows
      /// - Shortcuts point to files in ALL_PHOTOS
      /// - Shortcuts are valid and accessible file system entities
      /// - Platform-specific behavior is properly implemented
      ///
      /// **Validations**:
      /// - Test runs only on Windows platform
      /// - Album folders contain .lnk files
      /// - Shortcuts are valid file system entities
      /// - Proper Windows shortcut file structure
      ///
      /// **Note**: Skipped on non-Windows platforms
      test('Windows shortcut handling', () async {
        if (!Platform.isWindows) {
          // Skip on non-Windows platforms
          return;
        }

        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'shortcut',
        );

        final results = await _analyzeOutput(outputPath);

        // Check for .lnk files in album folders
        for (final albumFolder in results.albumFolders) {
          final albumFiles = await _getFilesInDirectory(albumFolder);
          final shortcuts = albumFiles
              .where((final f) => f.path.endsWith('.lnk'))
              .toList();
          expect(shortcuts.length, greaterThan(0));

          // Verify shortcuts are valid
          for (final shortcut in shortcuts) {
            final stat = await shortcut.stat();
            expect(stat.type, equals(FileSystemEntityType.file));
          }
        }
      });

      /// Tests Unix-specific symlink handling (symbolic links)
      ///
      /// **Purpose**: Validates that GPTH correctly creates Unix symbolic links
      /// when running on Unix-like platforms (Linux, macOS) in shortcut mode.
      ///
      /// **Expected Behavior**:
      /// - Symbolic links are created in album folders on Unix platforms
      /// - Symlinks point to valid targets in ALL_PHOTOS
      /// - Symlink targets exist and are accessible
      /// - Platform-specific symlink behavior is properly implemented
      ///
      /// **Validations**:
      /// - Test runs only on Unix-like platforms (not Windows)
      /// - Album folders contain symbolic links
      /// - Symlinks exist and point to valid targets
      /// - Target files exist and are accessible
      ///
      /// **Note**: Skipped on Windows platform
      test('Unix symlink handling', () async {
        if (Platform.isWindows) {
          // Skip on Windows
          return;
        }

        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'shortcut',
        );

        final results = await _analyzeOutput(outputPath);

        // Check for symlinks in album folders
        for (final albumFolder in results.albumFolders) {
          final albumFiles = await _getFilesInDirectory(albumFolder);
          final imageFiles = albumFiles
              .where((final f) => !f.path.endsWith('.json'))
              .toList();

          for (final file in imageFiles) {
            final link = Link(file.path);
            expect(await link.exists(), isTrue);

            // Verify symlink target exists
            final target = await link.target();
            expect(await File(target).exists(), isTrue);
          }
        }
      });
    });

    group('Performance and Data Integrity Tests', () {
      /// Tests performance with large datasets and validates processing efficiency
      ///
      /// **Purpose**: Validates that GPTH can handle large datasets efficiently
      /// and completes processing within reasonable time constraints.
      ///
      /// **Test Dataset**:
      /// - 5 years of photos (yearSpan: 5)
      /// - 10 albums (albumCount: 10)
      /// - 50 photos per year (photosPerYear: 50)
      /// - 20 album-only photos (albumOnlyPhotos: 20)
      /// - 80% EXIF ratio (exifRatio: 0.8)
      /// - Total: ~250+ files
      ///
      /// **Expected Behavior**:
      /// - Processing completes within 3 minutes
      /// - All files are processed successfully
      /// - Memory usage remains within reasonable bounds
      /// - Output structure is correct despite large dataset
      ///
      /// **Validations**:
      /// - File count exceeds 200 (large dataset processed)
      /// - All 10 albums are created
      /// - Processing time is under 3 minutes
      /// - Performance metrics are logged for analysis
      test('Large dataset performance', () async {
        // Generate larger dataset
        final largeTakeoutPath = await fixture.generateRealisticTakeoutDataset(
          yearSpan: 5,
          albumCount: 10,
          photosPerYear: 50,
          albumOnlyPhotos: 20,
          exifRatio: 0.8,
        );

        final largeOutputPath = p.join(fixture.basePath, 'large_output');
        await Directory(largeOutputPath).create(recursive: true);

        final stopwatch = Stopwatch()..start();

        await _runGpthProcess(
          takeoutPath: largeTakeoutPath,
          outputPath: largeOutputPath,
          albums: 'shortcut',
          timeout: const Duration(minutes: 5),
        );

        stopwatch.stop();

        final results = await _analyzeOutput(largeOutputPath);

        // Validate processing completed successfully
        expect(results.allPhotosFiles.length, greaterThan(200));
        expect(results.albumFolders.length, equals(10));

        // Validate reasonable performance (adjust thresholds as needed)
        expect(stopwatch.elapsed.inMinutes, lessThan(3));

        print('Large dataset processing time: ${stopwatch.elapsed}');
        print('Files processed: ${results.allPhotosFiles.length}');
        print('Albums created: ${results.albumFolders.length}');
      });

      /// Tests data integrity by comparing file hashes across locations
      ///
      /// **Purpose**: Validates that files maintain their integrity throughout
      /// the processing pipeline, especially when files are duplicated across
      /// ALL_PHOTOS and album folders.
      ///
      /// **Expected Behavior**:
      /// - Files in ALL_PHOTOS and album folders have identical content
      /// - SHA-256 hashes match between original and copied files
      /// - No data corruption occurs during file operations
      /// - Duplicate-copy mode produces bit-perfect copies
      ///
      /// **Validations**:
      /// - Hash comparison between ALL_PHOTOS and album files
      /// - Filename matching to ensure correct file relationships
      /// - Content verification for all duplicated files
      /// - Data integrity across the entire processing pipeline
      test('Data integrity validation', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'duplicate-copy',
        );

        final results = await _analyzeOutput(outputPath);

        // Validate file integrity by comparing hashes
        final allPhotosHashes = await _getFileHashes(results.allPhotosFiles);

        for (final albumFolder in results.albumFolders) {
          final albumFiles = await _getFilesInDirectory(albumFolder);
          final imageFiles = albumFiles
              .where((final f) => !f.path.endsWith('.json'))
              .toList();

          for (final file in imageFiles) {
            final fileHash = await _getFileHash(file);
            final filename = p.basename(file.path);

            // Find corresponding file in ALL_PHOTOS
            final allPhotosFile = results.allPhotosFiles.firstWhereOrNull(
              (final f) => p.basename(f.path) == filename,
            );

            if (allPhotosFile != null) {
              final allPhotosHash = allPhotosHashes[allPhotosFile.path];
              expect(
                fileHash,
                equals(allPhotosHash),
                reason: 'Hash mismatch for $filename',
              );
            }
          }
        }
      });

      /// Tests memory efficiency with resource limitations
      ///
      /// **Purpose**: Validates that GPTH can operate effectively even with
      /// limited memory resources, using the --limit-filesize flag.
      ///
      /// **Expected Behavior**:
      /// - Processing completes successfully despite memory constraints
      /// - JSON mode is used for minimal memory footprint
      /// - albums-info.json is created correctly
      /// - Files are processed without memory-related failures
      ///
      /// **Validations**:
      /// - Successful processing with limit-filesize flag
      /// - Expected number of files processed
      /// - albums-info.json file creation
      /// - No memory-related processing errors
      test('Memory usage with limited resources', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'json',
          limitFilesize: true,
        );

        final results = await _analyzeOutput(outputPath);

        // Should still process files successfully
        expect(results.allPhotosFiles.length, greaterThan(20));

        // Verify albums-info.json was created
        final albumsInfoFile = File(p.join(outputPath, 'albums-info.json'));
        expect(await albumsInfoFile.exists(), isTrue);
      });
    });

    group('Complex Flag Combinations', () {
      /// Tests combination: Shortcut + Year division + Copy + Write EXIF
      ///
      /// **Purpose**: Validates that multiple flags work correctly together
      /// without conflicts or unexpected behavior when combined.
      ///
      /// **Flag Combination**:
      /// - `--albums shortcut`: Create shortcuts in album folders
      /// - `--divide-to-dates 1`: Organize by year folders
      /// - `--copy`: Preserve original files
      /// - `--write-exif`: Write EXIF metadata
      ///
      /// **Expected Behavior**:
      /// - Year-based folder structure in ALL_PHOTOS
      /// - Album folders contain shortcuts to year-organized files
      /// - Original files remain in takeout directory
      /// - EXIF metadata is written to processed files
      ///
      /// **Validations**:
      /// - Year directories are created and validated
      /// - Album shortcuts point to year-organized files
      /// - Original files are preserved (copy mode)
      /// - All flags function correctly in combination
      test('Shortcut + Year division + Copy + Write EXIF', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'shortcut',
          divideToDates: 1,
          copy: true,
          writeExif: true,
        );

        final results = await _analyzeOutput(outputPath);

        // Validate year division structure using isYearFolder()
        final allPhotosDir = Directory(p.join(outputPath, 'ALL_PHOTOS'));
        final yearDirs = <Directory>[];
        await for (final entity in allPhotosDir.list()) {
          if (entity is Directory && isYearFolder(entity)) {
            yearDirs.add(entity);
          }
        }
        expect(yearDirs.length, greaterThan(0));

        // Validate shortcuts in albums
        expect(results.albumFolders.length, equals(5));

        // Validate original files preserved (copy mode)
        final originalFiles = await _getAllFiles(takeoutPath);
        expect(originalFiles.length, greaterThan(30));
      });

      /// Tests combination: Duplicate-copy + Month division + Skip extras + Transform Pixel
      ///
      /// **Purpose**: Validates a complex combination of processing flags that
      /// affect file organization, filtering, and transformation.
      ///
      /// **Flag Combination**:
      /// - `--albums duplicate-copy`: Create file copies in album folders
      /// - `--divide-to-dates 2`: Organize by year/month folders
      /// - `--skip-extras`: Exclude extra files from processing
      /// - `--transform-pixel-mp`: Transform Pixel megapixel format
      ///
      /// **Expected Behavior**:
      /// - Year/month hierarchical folder structure
      /// - Album folders contain actual file copies
      /// - Extra files are filtered out during processing
      /// - Pixel format transformations are applied
      ///
      /// **Validations**:
      /// - Year/month directory structure is created
      /// - Album folders contain actual copied files
      /// - Reduced file count due to extras filtering
      /// - Proper transformation of supported file formats
      test(
        'Duplicate-copy + Month division + Skip extras + Transform Pixel',
        () async {
          await _runGpthProcess(
            takeoutPath: takeoutPath,
            outputPath: outputPath,
            albums: 'duplicate-copy',
            divideToDates: 2,
            skipExtras: true,
            transformPixelMp: true,
          );

          final results = await _analyzeOutput(outputPath);

          // Validate month division structure using isYearFolder()
          final allPhotosDir = Directory(p.join(outputPath, 'ALL_PHOTOS'));
          final yearDirs = <Directory>[];
          await for (final entity in allPhotosDir.list()) {
            if (entity is Directory && isYearFolder(entity)) {
              yearDirs.add(entity);
            }
          }

          for (final yearDir in yearDirs) {
            final monthDirs = await Directory(
              yearDir.path,
            ).list().where((final e) => e is Directory).toList();
            expect(monthDirs.length, greaterThan(0));
          }

          // Validate duplicate copies in albums
          expect(results.albumFolders.length, equals(5));

          for (final albumFolder in results.albumFolders) {
            final albumFiles = await _getFilesInDirectory(albumFolder);
            final imageFiles = albumFiles
                .where((final f) => !f.path.endsWith('.json'))
                .toList();
            expect(imageFiles.length, greaterThan(0));
          }
        },
      );

      /// Tests combination: JSON + Day division + All processing flags
      ///
      /// **Purpose**: Validates the most complex flag combination with maximum
      /// granularity for both date organization and processing options.
      ///
      /// **Flag Combination**:
      /// - `--albums json`: Store album info in JSON metadata
      /// - `--divide-to-dates 3`: Organize by year/month/day folders
      /// - `--write-exif`: Write EXIF metadata to files
      /// - `--transform-pixel-mp`: Transform Pixel megapixel format
      /// - `--update-creation-time`: Update file creation times (Windows only)
      /// - `--limit-filesize`: Apply memory/filesize limitations
      ///
      /// **Expected Behavior**:
      /// - Three-level year/month/day folder hierarchy
      /// - Album information stored in JSON format only
      /// - All file processing flags applied correctly
      /// - Platform-specific creation time updates (Windows only)
      ///
      /// **Validations**:
      /// - Complete year/month/day directory structure
      /// - albums-info.json exists with proper structure
      /// - No separate album folders created
      /// - All processing flags function without conflicts
      test('JSON + Day division + All processing flags', () async {
        await _runGpthProcess(
          takeoutPath: takeoutPath,
          outputPath: outputPath,
          albums: 'json',
          divideToDates: 3,
          writeExif: true,
          transformPixelMp: true,
          updateCreationTime: Platform.isWindows,
          limitFilesize: true,
        );

        final results = await _analyzeOutput(outputPath);

        // Validate day division structure using isYearFolder()
        final allPhotosDir = Directory(p.join(outputPath, 'ALL_PHOTOS'));
        final yearDirs = <Directory>[];
        await for (final entity in allPhotosDir.list()) {
          if (entity is Directory && isYearFolder(entity)) {
            yearDirs.add(entity);
          }
        }
        expect(yearDirs.length, greaterThan(0));

        // Validate albums-info.json exists
        final albumsInfoFile = File(p.join(outputPath, 'albums-info.json'));
        expect(await albumsInfoFile.exists(), isTrue);

        // Validate no separate album folders
        expect(results.albumFolders.length, equals(0));
      });
    });
  });
}

// Helper classes and functions

/// **OutputAnalysis Class**
///
/// A data structure that holds the results of analyzing GPTH output directory.
/// Used to validate the correctness of processing results across all tests.
///
/// **Properties**:
/// - `allPhotosFiles`: List of all files found in the ALL_PHOTOS directory
/// - `albumFolders`: List of album directories created during processing
/// - `metadata`: Additional metadata about the processing results
///
/// **Usage**:
/// Returned by `_analyzeOutput()` and used throughout tests to validate
/// that GPTH has produced the expected output structure and file organization.
class OutputAnalysis {
  OutputAnalysis({
    required this.allPhotosFiles,
    required this.albumFolders,
    required this.metadata,
  });
  final List<File> allPhotosFiles;
  final List<Directory> albumFolders;
  final Map<String, dynamic> metadata;
}

/// **_runGpthProcess() Function**
///
/// Executes the GPTH (Google Photos Takeout Helper) process with specified parameters.
/// This is the core function that runs the actual GPTH binary for testing.
///
/// **Parameters**:
/// - `takeoutPath`: Input directory containing Google Photos takeout data
/// - `outputPath`: Output directory where organized files will be placed
/// - `albums`: Album processing mode ('shortcut', 'duplicate-copy', 'reverse-shortcut', 'json', 'nothing')
/// - `divideToDates`: Date organization level (0=single, 1=year, 2=year/month, 3=year/month/day)
/// - `copy`: If true, preserves original files; if false, moves them
/// - `skipExtras`: If true, excludes extra files (JSON, edited versions, etc.)
/// - `writeExif`: If true, writes EXIF metadata to processed files
/// - `transformPixelMp`: If true, applies Pixel megapixel transformations
/// - `updateCreationTime`: If true, updates file creation times (Windows only)
/// - `limitFilesize`: If true, applies memory/filesize limitations
/// - `timeout`: Maximum time to wait for process completion
///
/// **Returns**: Standard output from the GPTH process
///
/// **Throws**: Exception if the process fails or times out
///
/// **Usage**: Called by all test functions to execute GPTH with specific configurations
///
/// Runs GPTH process with specified parameters
Future<String> _runGpthProcess({
  required final String takeoutPath,
  required final String outputPath,
  final String albums = 'shortcut',
  final int divideToDates = 0,
  final bool copy = false,
  final bool skipExtras = false,
  final bool writeExif = false,
  final bool transformPixelMp = false,
  final bool updateCreationTime = false,
  final bool limitFilesize = false,
  final String specialFolders =
      'auto', // Add special-folders parameter with default 'auto'
  final Duration timeout = const Duration(minutes: 2),
}) async {
  final args = <String>[
    '--input',
    takeoutPath,
    '--output',
    outputPath,
    '--albums',
    albums,
    '--divide-to-dates',
    divideToDates.toString(),
    '--special-folders',
    specialFolders, // Add special-folders to arguments
    '--no-modify-json', // Preserve .supplemental-metadata.json format
  ];

  if (copy) args.add('--copy');
  if (skipExtras) args.add('--skip-extras');
  if (writeExif) args.add('--write-exif');
  if (transformPixelMp) args.add('--transform-pixel-mp');
  if (updateCreationTime) args.add('--update-creation-time');
  if (limitFilesize) args.add('--limit-filesize');

  // Run the process using Dart's VM
  final result = await Process.run('dart', [
    'run',
    'bin/gpth.dart',
    ...args,
  ], workingDirectory: '/Users/jens/development/GooglePhotosTakeoutHelper');

  if (result.exitCode != 0) {
    throw Exception(
      'GPTH process failed with exit code ${result.exitCode}\n'
      'STDOUT: ${result.stdout}\n'
      'STDERR: ${result.stderr}',
    );
  }

  return result.stdout.toString();
}

/// **_analyzeOutput() Function**
///
/// Analyzes the output directory structure created by GPTH and returns structured results.
/// This function is used by all tests to validate the correctness of GPTH processing.
///
/// **Purpose**:
/// - Identifies and counts files in ALL_PHOTOS directory
/// - Discovers and validates album folders using proper classification
/// - Collects metadata about the processing results
///
/// **Parameters**:
/// - `outputPath`: Path to the GPTH output directory to analyze
///
/// **Returns**: `OutputAnalysis` object containing:
/// - List of all files in ALL_PHOTOS directory
/// - List of valid album directories
/// - Metadata map with file counts and processing information
///
/// **Validation Logic**:
/// - Uses `isAlbumFolder()` to properly identify album directories
/// - Excludes ALL_PHOTOS from album folder classification
/// - Recursively finds all files in the ALL_PHOTOS hierarchy
///
/// **Usage**: Called after `_runGpthProcess()` to validate processing results
///
/// Analyzes the output directory structure and returns analysis results
Future<OutputAnalysis> _analyzeOutput(final String outputPath) async {
  final outputDir = Directory(outputPath);
  if (!await outputDir.exists()) {
    throw Exception('Output directory does not exist: $outputPath');
  }

  // Find ALL_PHOTOS directory
  final allPhotosDir = Directory(p.join(outputPath, 'ALL_PHOTOS'));
  final allPhotosFiles = await allPhotosDir.exists()
      ? await _getAllFiles(allPhotosDir.path)
      : <File>[];

  // Find album directories using the proper classification function
  final albumFolders = <Directory>[];
  await for (final entity in outputDir.list()) {
    if (entity is Directory) {
      final dirName = p.basename(entity.path);
      // Exclude ALL_PHOTOS and use isAlbumFolder() for proper classification
      if (dirName != 'ALL_PHOTOS' && await isAlbumFolder(entity)) {
        albumFolders.add(entity);
      }
    }
  }

  // Collect metadata
  final metadata = <String, dynamic>{
    'totalFiles': allPhotosFiles.length,
    'albumCount': albumFolders.length,
    'outputPath': outputPath,
  };

  return OutputAnalysis(
    allPhotosFiles: allPhotosFiles,
    albumFolders: albumFolders,
    metadata: metadata,
  );
}

/// **_getAllFiles() Function**
///
/// Recursively retrieves all files from a directory and its subdirectories.
/// Essential for counting and analyzing files in complex directory hierarchies.
///
/// **Parameters**:
/// - `dirPath`: Root directory path to search recursively
///
/// **Returns**: List of all File objects found in the directory tree
///
/// **Behavior**:
/// - Returns empty list if directory doesn't exist
/// - Recursively traverses all subdirectories
/// - Includes only files, excludes directories from results
///
/// **Usage**: Used to count files in takeout directories and output directories
///
/// Gets all files recursively from a directory
Future<List<File>> _getAllFiles(final String dirPath) async {
  final files = <File>[];
  final dir = Directory(dirPath);

  if (!await dir.exists()) {
    return files;
  }

  await for (final entity in dir.list(recursive: true)) {
    if (entity is File) {
      files.add(entity);
    }
  }

  return files;
}

/// **_getFilesInDirectory() Function**
///
/// Retrieves files from a single directory without recursion.
/// Used when analyzing specific directory levels like album folders.
///
/// **Parameters**:
/// - `dir`: Directory object to list files from
///
/// **Returns**: List of File objects in the immediate directory only
///
/// **Behavior**:
/// - Returns empty list if directory doesn't exist
/// - Non-recursive: only immediate children are included
/// - Filters to include only files, not subdirectories
///
/// **Usage**: Used to analyze album folder contents and validate shortcuts/copies
///
/// Gets all files in a single directory (non-recursive)
Future<List<File>> _getFilesInDirectory(final Directory dir) async {
  final files = <File>[];

  if (!await dir.exists()) {
    return files;
  }

  await for (final entity in dir.list()) {
    if (entity is File) {
      files.add(entity);
    }
  }

  return files;
}

/// **_getFileHash() Function**
///
/// Calculates SHA-256 hash for a single file to verify data integrity.
/// Critical for validating that file content remains unchanged during processing.
///
/// **Parameters**:
/// - `file`: File object to calculate hash for
///
/// **Returns**: SHA-256 hash as hexadecimal string
///
/// **Algorithm**: Uses SHA-256 cryptographic hash function for reliable content verification
///
/// **Usage**: Used in data integrity tests to ensure files are not corrupted during processing
///
/// Calculates SHA-256 hash for a single file
Future<String> _getFileHash(final File file) async {
  final bytes = await file.readAsBytes();
  final digest = sha256.convert(bytes);
  return digest.toString();
}

/// **_getFileHashes() Function**
///
/// Calculates SHA-256 hashes for multiple files efficiently.
/// Used for batch hash calculation and integrity verification.
///
/// **Parameters**:
/// - `files`: List of File objects to calculate hashes for
///
/// **Returns**: Map where keys are file paths and values are SHA-256 hashes
///
/// **Error Handling**:
/// - Logs warnings for files that cannot be hashed
/// - Continues processing remaining files if individual files fail
///
/// **Usage**: Used in data integrity tests to compare file content across locations
///
/// Gets hashes for multiple files
Future<Map<String, String>> _getFileHashes(final List<File> files) async {
  final hashes = <String, String>{};

  for (final file in files) {
    try {
      hashes[file.path] = await _getFileHash(file);
    } catch (e) {
      print('Warning: Could not hash file ${file.path}: $e');
    }
  }

  return hashes;
}

/// **_getUniqueFileHashes() Function**
///
/// Determines unique file content by collecting unique SHA-256 hashes.
/// Used to validate space efficiency in shortcut mode and detect duplicates.
///
/// **Parameters**:
/// - `files`: List of File objects to analyze for uniqueness
///
/// **Returns**: Set of unique SHA-256 hashes (no duplicates)
///
/// **Purpose**:
/// - Validates that shortcut mode doesn't duplicate file content
/// - Confirms that each file has unique content
/// - Helps verify space efficiency of different album modes
///
/// **Usage**: Used in shortcut mode tests to ensure no content duplication occurs
///
/// Gets unique file hashes from a list of files
Future<Set<String>> _getUniqueFileHashes(final List<File> files) async {
  final hashes = await _getFileHashes(files);
  return hashes.values.toSet();
}
